{"ast":null,"code":"import React from 'react';\nconst RECORD_OPTIONS = {\n  video: true,\n  audio: true\n};\nexport default class RecordingService {}\nRecordingService.videoRef = document.getElementById(\"video\");\nRecordingService.msgContainer = document.getElementById(\"message\");\n\nRecordingService.startRecording = async () => {\n  try {\n    RecordingService.videoRef.style.display = 'block';\n    RecordingService.videoRef.setAttribute('autoplay', true);\n    RecordingService.videoRef.srcObject = await navigator.mediaDevices.getDisplayMedia(RECORD_OPTIONS);\n    RecordingService.recordVideo(RecordingService.videoRef.srcObject);\n    return true;\n  } catch (err) {\n    console.error(\"Error: \" + err);\n    return false;\n  }\n};\n\nRecordingService.stopRecording = () => {\n  try {\n    let tracks = RecordingService.videoRef.srcObject.getTracks();\n    tracks.forEach(track => track.stop());\n    RecordingService.videoRef.srcObject = null;\n    RecordingService.removeMessage();\n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.pauseRecording = () => {\n  try {\n    let tracks = RecordingService.videoRef.srcObject.getTracks();\n    tracks.forEach(track => track.stop());\n    RecordingService.hideVideo();\n    RecordingService.showMessage(); // const d = mediaRecorder.requestData()  \n    // console.log(d)   \n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.hideVideo = () => {\n  RecordingService.videoRef.style.display = \"none\";\n};\n\nRecordingService.showMessage = () => {\n  try {\n    RecordingService.msgContainer.style.display = \"flex\";\n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.removeMessage = () => {\n  RecordingService.msgContainer.style.display = 'none';\n};\n\nRecordingService.recordVideo = stream => {\n  let recordedChunks = [];\n  const options = {\n    mimeType: 'video/webm;codecs=vp9'\n  };\n  mediaRecorder = new MediaRecorder(stream, options);\n  mediaRecorder.ondataavailable = handleDataAvailable;\n  mediaRecorder.start();\n\n  const handleDataAvailable = event => {\n    if (event.data.size > 0) {\n      recordedChunks.push(event.data);\n    }\n  };\n};","map":{"version":3,"sources":["/media/natehubbit/0051/null/topcoder/twine2/src/services/RecordingService.js"],"names":["React","RECORD_OPTIONS","video","audio","RecordingService","videoRef","document","getElementById","msgContainer","startRecording","style","display","setAttribute","srcObject","navigator","mediaDevices","getDisplayMedia","recordVideo","err","console","error","stopRecording","tracks","getTracks","forEach","track","stop","removeMessage","pauseRecording","hideVideo","showMessage","stream","recordedChunks","options","mimeType","mediaRecorder","MediaRecorder","ondataavailable","handleDataAvailable","start","event","data","size","push"],"mappings":"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","sourcesContent":["import React from 'react'\n\nconst RECORD_OPTIONS = {\n  video: true,\n  audio: true,\n}\n\nexport default class RecordingService {\n  /**\n   * static ref for video node\n   */\n  static videoRef = document.getElementById(\"video\")\n  static msgContainer = document.getElementById(\"message\")\n\n  /**\n   * function to record screen\n   */\n  static startRecording = async () => {\n    try {\n      this.videoRef.style.display='block'\n      this.videoRef.setAttribute('autoplay',true)\n      this.videoRef.srcObject = await navigator.mediaDevices.getDisplayMedia(RECORD_OPTIONS)\n      this.recordVideo(this.videoRef.srcObject)\n      return true\n    } catch (err) {\n      console.error(\"Error: \" + err)\n      return false\n    }\n  }\n\n  /**\n   * function to stop recording\n   */\n  static stopRecording = () => {\n    try {\n      let tracks = this.videoRef.srcObject.getTracks();\n      tracks.forEach(track => track.stop());\n      this.videoRef.srcObject = null;\n      this.removeMessage()\n    } catch (error) {\n      console.error(\"error: \",error) \n    }\n  }\n\n  /**\n   * function to pause recording\n   */\n  static pauseRecording = () => {\n    try {\n      let tracks = this.videoRef.srcObject.getTracks();\n      tracks.forEach(track => track.stop());\n      this.hideVideo()\n      this.showMessage()\n      // const d = mediaRecorder.requestData()  \n      // console.log(d)   \n    } catch (error) {\n      console.error(\"error: \",error)\n    }\n  }\n\n  /**\n   * function to hide video\n   */\n  static hideVideo = () => {\n    this.videoRef.style.display=\"none\"\n  }\n\n  /**\n   * function to show message on pause\n   */\n  static showMessage = () => {\n    try {\n      this.msgContainer.style.display=\"flex\"\n    } catch (error) {\n      console.error(\"error: \",error)\n    }\n  }\n\n  /**\n   * function to hide message\n   */\n  static removeMessage = () => {\n    this.msgContainer.style.display='none'\n  }\n\n  static recordVideo = (stream) => {\n    let recordedChunks = [];\n    const options = {mimeType: 'video/webm;codecs=vp9'};\n    mediaRecorder = new MediaRecorder(stream, options);\n    mediaRecorder.ondataavailable = handleDataAvailable;\n    mediaRecorder.start();\n\n    const handleDataAvailable = (event) => {\n      if (event.data.size > 0) {\n        recordedChunks.push(event.data);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}