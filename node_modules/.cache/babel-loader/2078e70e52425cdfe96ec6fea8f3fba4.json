{"ast":null,"code":"import React from 'react';\nconst RECORD_OPTIONS = {\n  video: {\n    cursor: \"always\"\n  },\n  audio: {\n    echoCancellation: true,\n    noiseSuppression: true,\n    sampleRate: 44100\n  }\n};\nexport default class RecordingService {}\nRecordingService.videoRef = document.getElementById(\"video\");\nRecordingService.msgContainer = document.getElementById(\"message\");\nRecordingService.mediaRecorder = null;\nRecordingService.micStream = null;\nRecordingService.fullStream = null;\nRecordingService.recordedChunks = [];\n\nRecordingService.startRecording = async () => {\n  try {\n    RecordingService.videoRef.style.display = 'block';\n    RecordingService.videoRef.setAttribute('autoplay', true);\n    RecordingService.recordVideo();\n    return true;\n  } catch (err) {\n    console.error(\"Error: \" + err);\n    return false;\n  }\n};\n\nRecordingService.stopRecording = () => {\n  try {\n    let tracks = RecordingService.videoRef.srcObject.getTracks();\n    tracks.forEach(track => track.stop());\n    RecordingService.videoRef.srcObject = null;\n    RecordingService.removeMessage();\n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.pauseRecording = () => {\n  try {\n    let tracks = RecordingService.videoRef.srcObject.getTracks();\n    tracks.forEach(track => track.stop());\n    RecordingService.hideVideo();\n    RecordingService.showMessage();\n    RecordingService.endRecording();\n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.hideVideo = () => {\n  RecordingService.videoRef.style.display = \"none\";\n};\n\nRecordingService.showMessage = () => {\n  try {\n    RecordingService.msgContainer.style.display = \"flex\";\n  } catch (error) {\n    console.error(\"error: \", error);\n  }\n};\n\nRecordingService.removeMessage = () => {\n  RecordingService.msgContainer.style.display = 'none';\n};\n\nRecordingService.recordVideo = async () => {\n  RecordingService.micStream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  RecordingService.videoRef.srcObject = await navigator.mediaDevices.getDisplayMedia(RECORD_OPTIONS);\n\n  const handleDataAvailable = event => {\n    if (event.data.size > 0) {\n      RecordingService.recordedChunks.push(event.data);\n    }\n  };\n\n  const options = {\n    mimeType: 'video/webm'\n  };\n  RecordingService.mediaRecorder = new MediaRecorder(RecordingService.videoRef.srcObject, options);\n  RecordingService.mediaRecorder.ondataavailable = handleDataAvailable;\n  RecordingService.mediaRecorder.start();\n};\n\nRecordingService.endRecording = async () => {\n  RecordingService.mediaRecorder.stop();\n  const hasAudio = RecordingService.micStream.getAudioTracks().length > 0;\n  const hasVideo = RecordingService.videoRef.srcObject.getVideoTracks.length > 0;\n\n  if (hasVideo) {\n    RecordingService.videoRef.srcObject.getVideoTracks().forEach(vid => {\n      RecordingService.fullStream.addTrack(vid);\n    });\n  }\n\n  if (hasAudio) {\n    RecordingService.micStream.getAudioTracks().forEach(audio => {\n      RecordingService.fullStream.addTrack(audio);\n    });\n  }\n\n  console.log(RecordingService.mediaRecorder.getAudioTracks());\n};\n\nRecordingService.downloadVideo = () => {\n  const blob = new Blob(RecordingService.recordedChunks, {\n    type: 'video/webm'\n  });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  document.body.appendChild(a);\n  a.style = 'display: none';\n  a.href = url;\n  a.download = 'video.webm';\n  a.click();\n  window.URL.revokeObjectURL(url);\n};","map":{"version":3,"sources":["/media/natehubbit/0051/null/topcoder/twine2/src/services/RecordingService.js"],"names":["React","RECORD_OPTIONS","video","cursor","audio","echoCancellation","noiseSuppression","sampleRate","RecordingService","videoRef","document","getElementById","msgContainer","mediaRecorder","micStream","fullStream","recordedChunks","startRecording","style","display","setAttribute","recordVideo","err","console","error","stopRecording","tracks","srcObject","getTracks","forEach","track","stop","removeMessage","pauseRecording","hideVideo","showMessage","endRecording","navigator","mediaDevices","getUserMedia","getDisplayMedia","handleDataAvailable","event","data","size","push","options","mimeType","MediaRecorder","ondataavailable","start","hasAudio","getAudioTracks","length","hasVideo","getVideoTracks","vid","addTrack","log","downloadVideo","blob","Blob","type","url","URL","createObjectURL","a","createElement","body","appendChild","href","download","click","window","revokeObjectURL"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,MAAMC,cAAc,GAAG;AACnBC,EAAAA,KAAK,EAAE;AACLC,IAAAA,MAAM,EAAE;AADH,GADY;AAInBC,EAAAA,KAAK,EAAE;AACLC,IAAAA,gBAAgB,EAAE,IADb;AAELC,IAAAA,gBAAgB,EAAE,IAFb;AAGLC,IAAAA,UAAU,EAAE;AAHP;AAJY,CAAvB;AAWA,eAAe,MAAMC,gBAAN,CAAuB;AAAjBA,gB,CAIZC,Q,GAAWC,QAAQ,CAACC,cAAT,CAAwB,OAAxB,C;AAJCH,gB,CAKZI,Y,GAAeF,QAAQ,CAACC,cAAT,CAAwB,SAAxB,C;AALHH,gB,CAMZK,a,GAAgB,I;AANJL,gB,CAOZM,S,GAAY,I;AAPAN,gB,CAQZO,U,GAAa,I;AARDP,gB,CASZQ,c,GAAiB,E;;AATLR,gB,CAcZS,c,GAAiB,YAAY;AAClC,MAAI;AAfaT,IAAAA,gBAgBf,CAAKC,QAAL,CAAcS,KAAd,CAAoBC,OAApB,GAA4B,OAA5B;AAhBeX,IAAAA,gBAiBf,CAAKC,QAAL,CAAcW,YAAd,CAA2B,UAA3B,EAAsC,IAAtC;AAjBeZ,IAAAA,gBAkBf,CAAKa,WAAL;AACA,WAAO,IAAP;AACD,GALD,CAKE,OAAOC,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAc,YAAYF,GAA1B;AACA,WAAO,KAAP;AACD;AACF,C;;AAxBkBd,gB,CA6BZiB,a,GAAgB,MAAM;AAC3B,MAAI;AACF,QAAIC,MAAM,GA/BKlB,gBA+BF,CAAKC,QAAL,CAAckB,SAAd,CAAwBC,SAAxB,EAAb;AACAF,IAAAA,MAAM,CAACG,OAAP,CAAeC,KAAK,IAAIA,KAAK,CAACC,IAAN,EAAxB;AAhCevB,IAAAA,gBAiCf,CAAKC,QAAL,CAAckB,SAAd,GAA0B,IAA1B;AAjCenB,IAAAA,gBAkCf,CAAKwB,aAAL;AACD,GALD,CAKE,OAAOR,KAAP,EAAc;AACdD,IAAAA,OAAO,CAACC,KAAR,CAAc,SAAd,EAAwBA,KAAxB;AACD;AACF,C;;AAtCkBhB,gB,CA2CZyB,c,GAAiB,MAAM;AAC5B,MAAI;AACF,QAAIP,MAAM,GA7CKlB,gBA6CF,CAAKC,QAAL,CAAckB,SAAd,CAAwBC,SAAxB,EAAb;AACAF,IAAAA,MAAM,CAACG,OAAP,CAAeC,KAAK,IAAIA,KAAK,CAACC,IAAN,EAAxB;AA9CevB,IAAAA,gBA+Cf,CAAK0B,SAAL;AA/Ce1B,IAAAA,gBAgDf,CAAK2B,WAAL;AAhDe3B,IAAAA,gBAiDf,CAAK4B,YAAL;AACD,GAND,CAME,OAAOZ,KAAP,EAAc;AACdD,IAAAA,OAAO,CAACC,KAAR,CAAc,SAAd,EAAwBA,KAAxB;AACD;AACF,C;;AArDkBhB,gB,CA0DZ0B,S,GAAY,MAAM;AA1DN1B,EAAAA,gBA2DjB,CAAKC,QAAL,CAAcS,KAAd,CAAoBC,OAApB,GAA4B,MAA5B;AACD,C;;AA5DkBX,gB,CAiEZ2B,W,GAAc,MAAM;AACzB,MAAI;AAlEa3B,IAAAA,gBAmEf,CAAKI,YAAL,CAAkBM,KAAlB,CAAwBC,OAAxB,GAAgC,MAAhC;AACD,GAFD,CAEE,OAAOK,KAAP,EAAc;AACdD,IAAAA,OAAO,CAACC,KAAR,CAAc,SAAd,EAAwBA,KAAxB;AACD;AACF,C;;AAvEkBhB,gB,CA4EZwB,a,GAAgB,MAAM;AA5EVxB,EAAAA,gBA6EjB,CAAKI,YAAL,CAAkBM,KAAlB,CAAwBC,OAAxB,GAAgC,MAAhC;AACD,C;;AA9EkBX,gB,CAgFZa,W,GAAc,YAAY;AAhFdb,EAAAA,gBAiFjB,CAAKM,SAAL,GAAiB,MAAMuB,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AAACnC,IAAAA,KAAK,EAAC;AAAP,GAApC,CAAvB;AAjFiBI,EAAAA,gBAkFjB,CAAKC,QAAL,CAAckB,SAAd,GAA0B,MAAMU,SAAS,CAACC,YAAV,CAAuBE,eAAvB,CAAuCvC,cAAvC,CAAhC;;AACA,QAAMwC,mBAAmB,GAAIC,KAAD,IAAW;AACrC,QAAIA,KAAK,CAACC,IAAN,CAAWC,IAAX,GAAkB,CAAtB,EAAyB;AApFVpC,MAAAA,gBAqFb,CAAKQ,cAAL,CAAoB6B,IAApB,CAAyBH,KAAK,CAACC,IAA/B;AACD;AACF,GAJD;;AAKA,QAAMG,OAAO,GAAG;AAACC,IAAAA,QAAQ,EAAE;AAAX,GAAhB;AAxFiBvC,EAAAA,gBAyFjB,CAAKK,aAAL,GAAqB,IAAImC,aAAJ,CAzFJxC,gBAyFsB,CAAKC,QAAL,CAAckB,SAAhC,EAA2CmB,OAA3C,CAArB;AAzFiBtC,EAAAA,gBA0FjB,CAAKK,aAAL,CAAmBoC,eAAnB,GAAqCR,mBAArC;AA1FiBjC,EAAAA,gBA2FjB,CAAKK,aAAL,CAAmBqC,KAAnB;AACD,C;;AA5FkB1C,gB,CA8FZ4B,Y,GAAe,YAAY;AA9Ff5B,EAAAA,gBA+FjB,CAAKK,aAAL,CAAmBkB,IAAnB;AACA,QAAMoB,QAAQ,GAhGG3C,gBAgGA,CAAKM,SAAL,CAAesC,cAAf,GAAgCC,MAAhC,GAAuC,CAAxD;AACA,QAAMC,QAAQ,GAjGG9C,gBAiGA,CAAKC,QAAL,CAAckB,SAAd,CAAwB4B,cAAxB,CAAuCF,MAAvC,GAA8C,CAA/D;;AACA,MAAGC,QAAH,EAAY;AAlGK9C,IAAAA,gBAmGf,CAAKC,QAAL,CAAckB,SAAd,CAAwB4B,cAAxB,GAAyC1B,OAAzC,CAAiD2B,GAAG,IAAE;AAnGvChD,MAAAA,gBAoGb,CAAKO,UAAL,CAAgB0C,QAAhB,CAAyBD,GAAzB;AACD,KAFD;AAGD;;AACD,MAAGL,QAAH,EAAa;AAvGI3C,IAAAA,gBAwGf,CAAKM,SAAL,CAAesC,cAAf,GAAgCvB,OAAhC,CAAwCzB,KAAK,IAAE;AAxGhCI,MAAAA,gBAyGb,CAAKO,UAAL,CAAgB0C,QAAhB,CAAyBrD,KAAzB;AACD,KAFD;AAGD;;AACDmB,EAAAA,OAAO,CAACmC,GAAR,CA5GiBlD,gBA4GL,CAAKK,aAAL,CAAmBuC,cAAnB,EAAZ;AACD,C;;AA7GkB5C,gB,CA+GZmD,a,GAAgB,MAAM;AAC3B,QAAMC,IAAI,GAAG,IAAIC,IAAJ,CAhHIrD,gBAgHK,CAAKQ,cAAd,EAA8B;AACzC8C,IAAAA,IAAI,EAAE;AADmC,GAA9B,CAAb;AAGA,QAAMC,GAAG,GAAGC,GAAG,CAACC,eAAJ,CAAoBL,IAApB,CAAZ;AACA,QAAMM,CAAC,GAAGxD,QAAQ,CAACyD,aAAT,CAAuB,GAAvB,CAAV;AACAzD,EAAAA,QAAQ,CAAC0D,IAAT,CAAcC,WAAd,CAA0BH,CAA1B;AACAA,EAAAA,CAAC,CAAChD,KAAF,GAAU,eAAV;AACAgD,EAAAA,CAAC,CAACI,IAAF,GAASP,GAAT;AACAG,EAAAA,CAAC,CAACK,QAAF,GAAa,YAAb;AACAL,EAAAA,CAAC,CAACM,KAAF;AACAC,EAAAA,MAAM,CAACT,GAAP,CAAWU,eAAX,CAA2BX,GAA3B;AACD,C","sourcesContent":["import React from 'react'\n\nconst RECORD_OPTIONS = {\n    video: {\n      cursor: \"always\"\n    },\n    audio: {\n      echoCancellation: true,\n      noiseSuppression: true,\n      sampleRate: 44100\n    }\n}\n\nexport default class RecordingService {\n  /**\n   * static ref for video node\n   */\n  static videoRef = document.getElementById(\"video\")\n  static msgContainer = document.getElementById(\"message\")\n  static mediaRecorder = null\n  static micStream = null\n  static fullStream = null\n  static recordedChunks = []\n\n  /**\n   * function to record screen\n   */\n  static startRecording = async () => {\n    try {\n      this.videoRef.style.display='block'\n      this.videoRef.setAttribute('autoplay',true)\n      this.recordVideo()\n      return true\n    } catch (err) {\n      console.error(\"Error: \" + err)\n      return false\n    }\n  }\n\n  /**\n   * function to stop recording\n   */\n  static stopRecording = () => {\n    try {\n      let tracks = this.videoRef.srcObject.getTracks();\n      tracks.forEach(track => track.stop());\n      this.videoRef.srcObject = null;\n      this.removeMessage()\n    } catch (error) {\n      console.error(\"error: \",error) \n    }\n  }\n\n  /**\n   * function to pause recording\n   */\n  static pauseRecording = () => {\n    try {\n      let tracks = this.videoRef.srcObject.getTracks();\n      tracks.forEach(track => track.stop());\n      this.hideVideo()\n      this.showMessage()\n      this.endRecording()\n    } catch (error) {\n      console.error(\"error: \",error)\n    }\n  }\n\n  /**\n   * function to hide video\n   */\n  static hideVideo = () => {\n    this.videoRef.style.display=\"none\"\n  }\n\n  /**\n   * function to show message on pause\n   */\n  static showMessage = () => {\n    try {\n      this.msgContainer.style.display=\"flex\"\n    } catch (error) {\n      console.error(\"error: \",error)\n    }\n  }\n\n  /**\n   * function to hide message\n   */\n  static removeMessage = () => {\n    this.msgContainer.style.display='none'\n  }\n\n  static recordVideo = async () => {\n    this.micStream = await navigator.mediaDevices.getUserMedia({audio:true})\n    this.videoRef.srcObject = await navigator.mediaDevices.getDisplayMedia(RECORD_OPTIONS)\n    const handleDataAvailable = (event) => {\n      if (event.data.size > 0) {\n        this.recordedChunks.push(event.data);\n      }\n    }\n    const options = {mimeType: 'video/webm'};\n    this.mediaRecorder = new MediaRecorder(this.videoRef.srcObject, options);\n    this.mediaRecorder.ondataavailable = handleDataAvailable;\n    this.mediaRecorder.start();\n  }\n\n  static endRecording = async () => {\n    this.mediaRecorder.stop()\n    const hasAudio = this.micStream.getAudioTracks().length>0\n    const hasVideo = this.videoRef.srcObject.getVideoTracks.length>0\n    if(hasVideo){\n      this.videoRef.srcObject.getVideoTracks().forEach(vid=>{\n        this.fullStream.addTrack(vid)\n      })\n    }\n    if(hasAudio) {\n      this.micStream.getAudioTracks().forEach(audio=>{\n        this.fullStream.addTrack(audio)\n      })\n    }\n    console.log(this.mediaRecorder.getAudioTracks())\n  }\n\n  static downloadVideo = () => {\n    const blob = new Blob(this.recordedChunks, {\n      type: 'video/webm'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.style = 'display: none';\n    a.href = url;\n    a.download = 'video.webm';\n    a.click();\n    window.URL.revokeObjectURL(url);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}